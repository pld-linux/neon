diff -urN neon-0.24.7.org/src/ne_request.c neon-0.24.7/src/ne_request.c
--- neon-0.24.7.org/src/ne_request.c	2004-07-05 11:49:05.000000000 +0200
+++ neon-0.24.7/src/ne_request.c	2004-11-21 01:33:48.000000000 +0100
@@ -110,6 +110,8 @@
 	    
     size_t body_size, body_progress;
 
+    int chunked;	/* send request incrementally chunked */
+
     /* temporary store for response lines. */
     char respbuf[BUFSIZ];
 
@@ -445,6 +447,29 @@
     return ret;
 }
 
+int ne_send_request_chunk(ne_request *req, const char *buffer, size_t size)
+{
+    char chunksize[20];
+    int ret;
+
+    ne_snprintf(chunksize, sizeof chunksize, "%x%s", size, EOL);
+    chunksize[sizeof(chunksize)-1] = '\0';
+
+    ret = ne_sock_fullwrite(req->session->socket, chunksize, strlen(chunksize));
+
+    if (!ret && size > 0)
+	ret = ne_sock_fullwrite(req->session->socket, buffer, size);
+
+    if (!ret)
+	ret = ne_sock_fullwrite(req->session->socket, EOL, sizeof(EOL)-1);
+
+    /* XXX Final EOL on last 0 byte chunk? perhaps call ne_finish_request? */
+    if (!ret && size == 0)
+	ret = ne_sock_fullwrite(req->session->socket, EOL, sizeof(EOL)-1);
+
+    return ret;
+}
+
 /* Lob the User-Agent, connection and host headers in to the request
  * headers */
 static void add_fixed_headers(ne_request *req) 
@@ -832,6 +857,11 @@
     return readlen;
 }
 
+void ne_set_request_chunked(ne_request *req, int chunked)
+{
+	req->chunked = chunked;
+}
+	
 /* Build the request string, returning the buffer. */
 static ne_buffer *build_request(ne_request *req) 
 {
@@ -978,6 +1008,10 @@
 	int aret = aborted(req, _("Could not send request"), ret);
 	return RETRY_RET(retry, ret, aret);
     }
+
+    /* Return with request in progress if sending incrementally chunked body. */
+    if (req->chunked)
+	return ret;
     
     if (!req->use_expect100 && req->body_size > 0) {
 	/* Send request body, if not using 100-continue. */
@@ -1154,36 +1188,10 @@
     }
 }
 
-int ne_begin_request(ne_request *req)
+int ne_finish_request(ne_request *req)
 {
     struct body_reader *rdr;
-    struct host_info *host;
-    ne_buffer *data;
     const ne_status *const st = &req->status;
-    int ret;
-
-    /* Resolve hostname if necessary. */
-    host = req->session->use_proxy?&req->session->proxy:&req->session->server;
-    if (host->address == NULL)
-	HTTP_ERR(lookup_host(req->session, host));
-
-    req->resp.mode = R_TILLEOF;
-    
-    /* FIXME: Determine whether to use the Expect: 100-continue header. */
-    req->use_expect100 = (req->session->expect100_works > -1) &&
-	(req->body_size > HTTP_EXPECT_MINSIZE) && req->session->is_http11;
-
-    /* Build the request string, and send it */
-    data = build_request(req);
-    DEBUG_DUMP_REQUEST(data->data);
-    ret = send_request(req, data);
-    /* Retry this once after a persistent connection timeout. */
-    if (ret == NE_RETRY && !req->session->no_persist) {
-	NE_DEBUG(NE_DBG_HTTP, "Persistent connection timed out, retrying.\n");
-	ret = send_request(req, data);
-    }
-    ne_buffer_destroy(data);
-    if (ret != NE_OK) return ret;
 
     /* Determine whether server claims HTTP/1.1 compliance. */
     req->session->is_http11 = (st->major_version == 1 && 
@@ -1206,9 +1214,9 @@
     }
 #endif
 
-    /* HEAD requests and 204, 205, 304 responses have no response body,
+    /* HEAD requests and 201, 204, 205, 304 responses have no response body,
      * regardless of what headers are present. */
-    if (req->method_is_head || st->code==204 || st->code==205 || st->code==304)
+    if (req->method_is_head || st->code==201 || st->code==204 || st->code==205 || st->code==304)
     	req->resp.mode = R_NO_BODY;
 
     /* Prepare for reading the response entity-body.  Call each of the
@@ -1224,6 +1232,42 @@
     return NE_OK;
 }
 
+int ne_begin_request(ne_request *req)
+{
+    struct body_reader *rdr;
+    struct host_info *host;
+    ne_buffer *data;
+    const ne_status *const st = &req->status;
+    int ret;
+
+    /* Resolve hostname if necessary. */
+    host = req->session->use_proxy?&req->session->proxy:&req->session->server;
+    if (host->address == NULL)
+	HTTP_ERR(lookup_host(req->session, host));
+
+    req->resp.mode = R_TILLEOF;
+    
+    /* Build the request string, and send it */
+    data = build_request(req);
+    DEBUG_DUMP_REQUEST(data->data);
+    ret = send_request(req, data);
+    /* Retry this once after a persistent connection timeout. */
+    if (ret == NE_RETRY && !req->session->no_persist && !req->chunked) {
+	NE_DEBUG(NE_DBG_HTTP, "Persistent connection timed out, retrying.\n");
+	ret = send_request(req, data);
+    }
+    ne_buffer_destroy(data);
+    if (ret != NE_OK) return ret;
+
+    /* Return with request in progress if sending incrementally chunked body. */
+    if (req->chunked)
+	return ret;	/* XXX perhaps NE_INPROGRESS? */
+
+    ret = ne_finish_request(req);
+
+    return ret;
+}
+
 int ne_end_request(ne_request *req)
 {
     struct hook *hk;
diff -urN neon-0.24.7.org/src/ne_request.h neon-0.24.7/src/ne_request.h
--- neon-0.24.7.org/src/ne_request.h	2003-10-22 22:47:05.000000000 +0200
+++ neon-0.24.7/src/ne_request.h	2004-11-21 01:35:15.000000000 +0100
@@ -258,6 +258,20 @@
 void ne_set_request_private(ne_request *req, const char *id, void *priv);
 void *ne_get_request_private(ne_request *req, const char *id);
 
+/* Mark the request body as incrementally chunked. */
+void ne_set_request_chunked(ne_request *req, int chunked)
+      /*@modifies req @*/;
+
+/* Send request body chunk.
+ * Return 0 on success, else NE_* return. */
+int ne_send_request_chunk(ne_request *req, const char *buffer, size_t size)
+      /*@modifies req @*/;
+
+/* Finish incrementally chunked request. */
+int ne_finish_request(ne_request *req)
+      /*@globals internalState @*/
+      /*@modifies req, internalState @*/;
+
 END_NEON_DECLS
 
 #endif /* NE_REQUEST_H */
